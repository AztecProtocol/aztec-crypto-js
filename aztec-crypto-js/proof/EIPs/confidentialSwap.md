---
eip: <>
title: <Confidential swap proof>
author: <a list of the author's or authors' name(s) and/or username(s), or name(s) and email(s), e.g. (use with the parentheses or triangular brackets): FirstName LastName (@GitHubUsername), FirstName LastName <foo@bar.com>, FirstName (@GitHubUsername) and GitHubUsername (@GitHubUsername)>
discussions-to: <URL>
status: Draft
type: <Standards Track (Core, Networking, Interface, ERC)  | Informational | Meta>
category (*only required for Standard Track): <Core | Networking | Interface | ERC>
created: <date created on, in ISO 8601 (yyyy-mm-dd) format>
requires (*optional): <EIP number(s)>
replaces (*optional): <EIP number(s)>
---


# Simple Summary
This EIP defines the interface and behaviour of the AZTEC based zero-knowledge confidential swap functionality.

# Abstract
The confidential swap proof construction and validation EIP tackles the problem of two entities not being able to exchange assets on a public blockchain confidentially. The AZTEC protocol is used to first represent these digital assets in confidential form, via AZTEC notes, and then a zero knowledge confidential swap proof as described in x is implemented. There are two distinct parts of the code base. Firstly, a client side Javascript proof construction module and secondly a verification smart contract. 

# Motivation
Currently, if two entities wish to execute a trade of two assets A and B on a public blockchain, then it is not possible to keep the bid and ask prices confidential. This substantially limits the utility of a public blockchain, such as Ethereum, for applications where privacy is required. 

The AZTEC protocol can be used to solve this problem as for the first time it enables confidential transactions on Ethereum. This is achieved, in part, through the introduction of a new type of digital asset referred to as an AZTEC note. A note is an encrypted representation of abstract value and it can be used to define a confidential digital asset - an asset in which both the value and owner are unknown to the outside world. This has no traditional analogue. 

AZTEC notes are stored in note registries, similar to the traditional analogue of balance registries. They can be used to transact confidentially via a 'join-split' transaction, a process in which the input notes are destroyed and a set of output notes created with the note value and owner assigned according to the details of the transaction. This is all done in zero-knowledge, that is the values of the AZTEC notes are never revealed and instead they 

This EIP makes use of the AZTEC protocol to facilitate the confidential swap of two assets.

# Specification
The specification implements the zero-knowledge proof described in the 'Atomic cross-asset swap' paper, available at x.

The confidential swap makes the assumption that the digital assets are already represented in confidential form by AZTEC notes and that a trade is being facilitated between two entities, an order maker and order taker. The maker owns a note from asset A and desires a note from asset B. The taker owns a note from asset B and desires a note from asset A. As such, the taker owns a note from asset B. Hence, the following notes are defined:  
* Maker bid note
* Maker ask note
* Taker ask note
* Taker bid note 

There are then two distinct stages to the confidential swap. Firstly, a proof construction stage generated by the constructAtomicSwap() method in atomicSwapProof.js. This generates the data associated with a zero-knowledge proof that the maker bid note matches the taker ask note and vice versa. 

There is then a verification stage performed by the AtomicSwap.sol smart contract. This checks if the proof is valid - it if is, then the swap goes ahead and if not then the swap is rejected.  

## atomicSwapProof.constructAtomicSwap(notes, sender)
This implements the P_swap algorithm as set out in the paper. 

### Inputs: (notes, sender)
* notes: array of the maker bid, maker ask, taker ask and taker bid notes. The notes themselves are xxxx. 

* sender: Ethereum address from which the proof construction transaction is sent. 

### Outputs: (proofData, challenge)
* proofData: array of 6 elements, where the elements are hexademical strings. Structued as (kBar, aBar, gamma_x, gamma_y, sigma_x, sigma_y)
* challenge: hexademical string 


## AtomicSwap.sol
This implements the V_swap algorithm as set out in the paper. The smart contract is written in YUL to enable manual memory management and has one fallback function validateAtomicSwap().

### Inputs: (bytes32[6][], uint, bytes32[4])
* bytes32[6][]: a dynamic array of 6 32 byte elements, representing the input proof data. For the purposes of a confidential swap, a static array of 4 elements could be used. However, to maintain consistency across the calldata maps of the various smart contracts in the AZTEC cryptographic engine it was decided to keep this as a dynamic array. A check is included in the contract to ensure it throws if more than 4 notes worth of information is input.
* uint: a 32 byte type representing the challenge
* bytes32[4]: a static 32 byte array of 4 elements representing the trusted setup public key, t_2

### Outputs: (bool)
* bool: a boolean that evalutes to 'true' if the proof was accepted and 'false' if the proof was rejected

### Memory map
To reduce gas costs, a hard-coded memory map has been used. The design is as follows:  
* 0x00:0x20       = scratch data to store result of keccak256 calls
* 0x20:0x80       = scratch data to store \gamma_i and a multiplication scalar
* 0x80:0xc0       = x-coordinate of generator h
* 0xc0:0xe0       = y-coordinate of generator h
* 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by
* 0x100:0x160     = scratch data to store \sigma_i and a multiplication scalar
* 0x160:0x1a0     = stratch data to store result of G1 point additions
* 0x1a0:0x1c0     = scratch data to store result of \sigma_i^{-cx_{i-m-1}}
* 0x220:0x260     = scratch data to store \gamma_i^{cx_{i-m-1}}
* 0x2e0:0x300     = msg.sender (contract should be called via delegatecall/staticcall)
* 0x300:???       = block of memory that contains (\gamma_i, \sigma_i)_{i=0}^{n-1} concatenated with (B_i)_{i=0}^{n-1}

## Gas cost
The cost for a typical confidential swap involving two entities is ~600,000 gas. 

# Test Cases

# Implementation

