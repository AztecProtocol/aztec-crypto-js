---
id: lib_Security_Security
title: Security
---

<div class="contract-doc"><div class="contract"><h2 class="contract-header"><span class="contract-kind">library</span> Security</h2><p class="description">Libraries are functionally similar to contracts, with some key differences libraries cannot have their own storage variables (they have no persistant state) They are designed to have their methods called by other contracts or libraries There are two fundamental ways smart contracts can interface with a library The first is by referencing a &#x27;library&#x27; smart contract instantiated at a specific address. The second is to incorporate a library&#x27;s bytecode directly into a smart contract (done by the compiler) The former is useful for complex methods \ as it means multiple smart contracts can reference a single library and reduce the amount of raw bytecode that needs to be  deployed on-chain The latter is useful for small helper functions, where the gas cost of calling an external smart contract would be excessive. This is done by declaring a library function to be `internal`. This notifies the Solidity compiler to incorporate the function&#x27;s bytecode in any contract that uses the library., It costs 700 gas to call an external library instantiated at a specific smart contract address. When creating a smart contract, it costs 200 gas per byte of bytecode the contract contains. Whether a library&#x27;s methods should be internal or not depends on which of the above two is worth minimizing for a given method.</p><div class="source">Source: <a href="git+https://github.com/CreditMint/smart-contracts/blob/v0.0.1/contracts/lib/Security/Security.sol" target="_blank">lib/Security/Security.sol</a></div></div><div class="index"><h2>Index</h2><ul><li><a href="lib_Security_Security.html#Debug2">Debug2</a></li><li><a href="lib_Security_Security.html#Debug3">Debug3</a></li><li><a href="lib_Security_Security.html#getSignatureAddress">getSignatureAddress</a></li></ul></div><div class="reference"><h2>Reference</h2><div class="events"><h3>Events</h3><ul><li><div class="item event"><span id="Debug2" class="anchor-marker"></span><h4 class="name">Debug2</h4><div class="body"><code class="signature">event <strong>Debug2</strong><span>(bytes32 message) </span></code><hr/><dl><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>message</code> - bytes32</div></dd></dl></div></div></li><li><div class="item event"><span id="Debug3" class="anchor-marker"></span><h4 class="name">Debug3</h4><div class="body"><code class="signature">event <strong>Debug3</strong><span>(address signingAddr) </span></code><hr/><dl><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>signingAddr</code> - address</div></dd></dl></div></div></li></ul></div><div class="functions"><h3>Functions</h3><ul><li><div class="item function"><span id="getSignatureAddress" class="anchor-marker"></span><h4 class="name">getSignatureAddress</h4><div class="body"><code class="signature">function <strong>getSignatureAddress</strong><span>(ECDSASignature signature) </span><span>internal </span><span>view </span><span>returns  (address) </span></code><hr/><div class="description"><p>The &#x27;message&#x27; of the signature needs to be the address of the whoever called the parent contract cast `parent` to a ParentInterface contract type, so that we can call the `isWhitelisted` method. If this method does not exist the function should throw.</p></div><dl><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>signature</code> - ECDSASignature</div></dd><dt><span class="label-return">Returns:</span></dt><dd>a boolean depending on if signer of signature is part of whitelist</dd></dl></div></div></li></ul></div></div></div>
